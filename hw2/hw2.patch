diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h
index a067410eb..f1edc2195 100644
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@ -863,6 +863,19 @@ struct kvm_ppc_resize_hpt {
 #define KVM_VM_TYPE_ARM_IPA_SIZE_MASK	0xffULL
 #define KVM_VM_TYPE_ARM_IPA_SIZE(x)		\
 	((x) & KVM_VM_TYPE_ARM_IPA_SIZE_MASK)
+
+/**
+ * vm class
+ */
+struct kvm_arm_write_gpa_args {
+       uint32_t vmid;  // the vmid that you, as the host, want to write to
+       uint64_t gpa;   // the gpa of the guest
+       uint64_t data;  // address of the payload in host user space
+       uint64_t size;  // size of the payload
+};
+
+#define KVM_ARM_WRITE_GPA         _IOW(KVMIO,   0xfe, struct kvm_arm_write_gpa_args)
+
 /*
  * ioctls for /dev/kvm fds:
  */
diff --git a/tools/include/uapi/linux/kvm.h b/tools/include/uapi/linux/kvm.h
index a067410eb..f1edc2195 100644
--- a/tools/include/uapi/linux/kvm.h
+++ b/tools/include/uapi/linux/kvm.h
@@ -863,6 +863,19 @@ struct kvm_ppc_resize_hpt {
 #define KVM_VM_TYPE_ARM_IPA_SIZE_MASK	0xffULL
 #define KVM_VM_TYPE_ARM_IPA_SIZE(x)		\
 	((x) & KVM_VM_TYPE_ARM_IPA_SIZE_MASK)
+
+/**
+ * vm class
+ */
+struct kvm_arm_write_gpa_args {
+       uint32_t vmid;  // the vmid that you, as the host, want to write to
+       uint64_t gpa;   // the gpa of the guest
+       uint64_t data;  // address of the payload in host user space
+       uint64_t size;  // size of the payload
+};
+
+#define KVM_ARM_WRITE_GPA         _IOW(KVMIO,   0xfe, struct kvm_arm_write_gpa_args)
+
 /*
  * ioctls for /dev/kvm fds:
  */
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 7851f3a1b..bbfc34d3d 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -4653,6 +4653,42 @@ static int kvm_dev_ioctl_create_vm(unsigned long type)
 	return r;
 }
 
+/**
+ * vm class
+*/
+// 展示所有 vmid
+static void show_vm_vid(void)
+{
+	struct kvm *kvm;
+	mutex_lock(&kvm_lock);
+	printk("show kvm vmid start:");
+	list_for_each_entry (kvm, &vm_list, vm_list) {
+		printk("kvm vmid : %d", kvm->arch.mmu.vmid.vmid);
+	}
+	printk("show kvm vmid end!");
+	mutex_unlock(&kvm_lock);
+
+	return;
+}
+
+// 獲取 id 符合的 VM pointer
+static struct kvm * get_vm_by_id(uint32_t vmid)
+{
+	struct kvm *kvm;
+	struct kvm *target_vm = 0;
+
+	mutex_lock(&kvm_lock);
+	list_for_each_entry (kvm, &vm_list, vm_list) {
+		if (kvm->arch.mmu.vmid.vmid == vmid) {
+			target_vm = kvm;
+		}
+	}
+	mutex_unlock(&kvm_lock);
+
+	return target_vm;
+}
+
+
 static long kvm_dev_ioctl(struct file *filp,
 			  unsigned int ioctl, unsigned long arg)
 {
@@ -4664,6 +4700,28 @@ static long kvm_dev_ioctl(struct file *filp,
 			goto out;
 		r = KVM_API_VERSION;
 		break;
+	/**
+ 	 * vm class
+ 	 */
+	case KVM_ARM_WRITE_GPA:
+		struct kvm_arm_write_gpa_args *gpa_para_struct = (struct kvm_arm_write_gpa_args*)(void *)arg;
+		struct kvm *target_vm = get_vm_by_id(gpa_para_struct->vmid);
+		if (!target_vm) {
+			printk("kvm error: can not find target vm");
+			show_vm_vid();
+			r = 0;
+			break;
+		}
+		// kvm_vcpu_write_guest 變更 vcpu (存數據)
+		kvm_vcpu_write_guest(target_vm->vcpus[0], gpa_para_struct->gpa,
+				     (void *)gpa_para_struct->data, gpa_para_struct->size);
+		// 用 kvm_make_request (check_vcpu_requests) 創造中斷, request CPU pending
+		kvm_make_request(KVM_REQ_SLEEP, target_vm->vcpus[0]);
+		// 用 kvm_vcpu_kick 叫醒 CPU (optional 可以被動等待 VMM 叫醒)
+		kvm_vcpu_kick(target_vm->vcpus[0]);
+		
+		r = 0;
+		break;
 	case KVM_CREATE_VM:
 		r = kvm_dev_ioctl_create_vm(arg);
 		break;
